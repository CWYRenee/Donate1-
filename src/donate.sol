// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol";

contract Donate is KeeperCompatibleInterface {
    uint256 donationID;
    uint256 donationUnit;
    address payable private donor;
    address payable charity;
    uint256 public amount;
    uint256 public totalDonated;

    // //Time interval between payments
    uint256 public interval;
    //Last payment time
    uint256 public lastTimeStamp;

    event myEventTest(uint, address, uint);

    function set(address charityAddress, uint intervalTime) public {
        charity = payable(charityAddress);
        interval = intervalTime;
        emit myEventTest(amount, charity, interval);
    }

    constructor(uint256 updateInterval) {
        donationID;
        donationUnit;
        donor;
        charity;
        interval = updateInterval;
        amount = msg.sender.balance / 100;
        lastTimeStamp = block.timestamp;
        totalDonated;
    }

    // Define a public mapping 'donations' that maps the donationID to a Donation.
    mapping(uint256 => Donation) public donations;
    // Define a struct 'Donation' with the following fields:
    struct Donation {
        uint256 donationID;
        uint256 donationUnit; //Number of donations
        address donor;
        address charity;
        uint256 amount;
        uint256 donationDate;
    }

    //calculate amount to donate
    function calculateDonation() private returns (uint){
        return amount = donor.balance / 100;
    }

    //kill contract
    function unSubscribe(address donor) public {
        require(msg.sender == donor, "only donor can unsubscribe");
        selfdestruct(payable(charity));
    }

    //Called by Chainlink Keepers to check if work needs to be done
    function checkUpkeep(
        bytes calldata /*checkData */
    ) external override returns (bool upkeepNeeded, bytes memory) {
        upkeepNeeded =
            (charity != address(0)) &&
            ((block.timestamp - lastTimeStamp) > interval) &&
            (donor.balance != 0);
    }

    //Called by Chainlink Keepers to handle work
    function performUpkeep(bytes calldata) external override {
        lastTimeStamp = block.timestamp;
        calculateDonation();
        sendDonation(charity);
    }

    function get()public view returns (uint) {
        return amount;
    }

    function sendDonation(address payable _charity)
        public
        payable
    {
        require(
            msg.value <= donor.balance,
            "trying to transact more than you have"
        );
        require(
            msg.sender != _charity,
            "donor address is the same as charity address- can't donate to yourself"
        );
        require(
            msg.sender == donor,
            "mismatch of msg.sender and donor address"
        );
        require(
            donations[donationID].amount <= donor.balance,
            "invalid, donating more than you have"
        );
    

        Donation memory newDonation; // Create a new struct Donation (Donation) in memory
        newDonation.donationID = donationID; // Universal Donation ID (donationID), generated by the Donor, goes on the package, can be verified by the Charity
        newDonation.donationUnit = donationUnit;
        newDonation.donor = msg.sender; // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        newDonation.donationDate = block.timestamp; //Donation timestamp
        newDonation.amount = get(); // Donation Amount
        newDonation.charity = _charity; // Metamask-Ethereum address of the Charity // ADDED payable
        donations[donationID] = newDonation; // Add newDonation to donations struct by donationID

        _charity.transfer(donations[donationID].amount);

        donationID += 1;
        donationUnit += 1;
        totalDonated += donations[donationID].amount;
    }
}
